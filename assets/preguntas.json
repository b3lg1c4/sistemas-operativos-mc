[
    {
        "id_pregunta": 0,
        "pregunta": "¿Que diferencias hay entre Multiprogramacion y Multiprocesamiento?",
        "respuestas": [
            {
                "respuesta": "Multiprogramación:\n\n Es la capacidad de ejecutar varios procesos que residen en memoria en forma concurrente repartiendo el uso de la CPU entre cada uno de ellos. Multiprocesamiento: Consiste en ejecutar varios procesos en forma simultánea a traves de varios\n\n procesadores trabajando a la vez.",
                "esCorrecta": true
            },
            {
                "respuesta": "Multiprogramación: Consiste en ejecutar varios procesos en forma simultanea a traves de varios procesadores trabajando a la vez. Multiprocesamiento: Es la capacidad de ejecutar varios procesos que residen en memoria en forma concurrente repartiendo el uso de la CPU entre cada uno de ellos.",
                "esCorrecta": false
            },
            {
                "respuesta": "Multiprogramación:\n\n Es la capacidad de ejecutar varios procesos que residen en la memoria auxiliar en forma concurrente repartiendo el uso de la CPU entre cada uno de ellos. Multiprocesamiento: Es la capacidad de ejecutar varios procesos que residen en memoria en forma concurrente repartiendo el uso de la CPU entre cada uno de ellos.",
                "esCorrecta": false
            }
        ]
    },
    {
        "id_pregunta": 1,
        "pregunta": "Independientemente del SO, una estructura de subcolas permite clasificar programas dinámicamente según características intrínsecas de los mismos. ¿A qué características nos referimos?",
        "respuestas": [
            {
                "respuesta": "1) Prioridad relativa. 2) Tiempo límite de inicio y fin. 3) Llenado de memoria 4) Recursos limites 5) Grado de avance",
                "esCorrecta": true
            },
            {
                "respuesta": "1) Prioridad relativa. 2) Grado de avance. 3) Recursos limites",
                "esCorrecta": false
            },
            {
                "respuesta": "1) Tiempo límite de inicio y fin. 2) Prioridad relativa. 3) Desbordamiento de pila 4) Memoria completa",
                "esCorrecta": false
            }
        ]
    },
    {
        "id_pregunta": 2,
        "pregunta": "¿A qué se denomina TRASHING y cómo se soluciona?",
        "respuestas": [
            {
                "respuesta": "Se denomina Trashing a la hiperpaginación. Ocurre cuando en un proceso se emplea mas tiempo paginando que ejecutando el proceso, los recursos del sistema están siendo utilizados por los mecanismos de paginación, no quedando disponibles (o quedando muy poco) tiempo asignado para el progreso de los programas. Se soluciona aplicando un algoritmo en forma local, es decir, ante la necesidad de un proceso de una nueva página debe elegirse la página víctima dentro de las de ese proceso. Las paginas de cada proceso se asignan basandose en el modelo de area activa. Tambien se puede solucionar reduciendo el nivel de multiprogramación.",
                "esCorrecta": true
            },
            {
                "respuesta": "Se denomina Trashing al proceso que se emplea mas tiempo paginando que ejecutando los recursos del sistema los cuales están siendo utilizados por los mecanismos de paginación, no quedando disponibles (o quedando muy poco) tiempo asignado para el progreso de los programas. Se soluciona aplicando un algoritmo en forma local, es decir, ante la necesidad de un proceso de una nueva página debe elegirse la página víctima dentro de las de ese proceso. Las paginas de cada proceso se asignan basandose en el modelo de area activa. Tambien se puede solucionar reduciendo el nivel de multiprogramación.",
                "esCorrecta": false
            },
            {
                "respuesta": "Se denomina Trashing al tiempo asignado para el progreso de los programas TRASH de la memoria de paginación. Se soluciona aplicando un algoritmo en forma local, es decir, ante la necesidad de un proceso de una nueva página debe elegirse la página víctima dentro de las de ese proceso. Las paginas de cada proceso se asignan basandose en el modelo de area activa. Tambien se puede solucionar reduciendo el nivel de multiprogramación.",
                "esCorrecta": false
            }
        ]
    },
    {
        "id_pregunta": 3,
        "pregunta": "¿Cuál es la diferencia entre vecindad (o localidad) y C.P.T?",
        "respuestas": [
            {
                "respuesta": "Vecindad o Localidad: Es el conjunto de páginas que se utilizan conjuntamente. Se considera que un programa está formado por un conjunto de vecindades, las cuales pueden superponerse. C.P.T.: Representación aproximada del tamaño de la vecindad de un programa. Se obtiene sobre el análisis del pasado reciente de un programa.",
                "esCorrecta": true
            },
            {
                "respuesta": "Vecindad o Localidad: Representación aproximada del tamaño de la vecindad de un programa. Se obtiene sobre el análisis del pasado reciente de un programa. C.P.T.: Es el conjunto de páginas que se utilizan conjuntamente. Se considera que un programa está formado por un conjunto de vecindades, las cuales pueden superponerse.",
                "esCorrecta": false
            },
            {
                "respuesta": "Vecindad o Localidad: Representación aproximada del tamaño de un marco de memoria principal. C.P.T. : Abreviación de cola de procesos trabados, se da cuando el proceso queda indefinidamente sin procesar por un error del procesador",
                "esCorrecta": false
            }
        ]
    },
    {
        "id_pregunta": 4,
        "pregunta": "¿El ONI es un administrador de recursos? ¿El OAN? ¿Por qué?",
        "respuestas": [
            {
                "respuesta": "El ONI es un recurso que está en la CPU al decidir qué trabajos van a correr en la mezcla. El OAN influye pero no toma ninguna decisión acerca de qué programas utilizará la CPU.",
                "esCorrecta": false
            },
            {
                "respuesta": "El ONI es una administrador de recursos porque está administrando la CPU al decidir qué trabajos van a correr en la mezcla. El OAN influye pero no toma ninguna decisión acerca de qué programas utilizará la CPU.",
                "esCorrecta": true
            },
            {
                "respuesta": "El ONI son conjuntos de trabajos los cuales administran los recursos del CPU. El OAN influye pero no toma ninguna decisión acerca de qué programas utilizará la CPU.",
                "esCorrecta": false
            }
        ]
    },
    {
        "id_pregunta": 5,
        "pregunta": "Dado un sistema de multiprogramación avanzada que cuenta con estructuras de subcolas y en el que corre una mezcla heterogénea en el uso de recursos, ¿por qué puede producirse un desbalance en el uso de recursos?",
        "respuestas": [
            {
                "respuesta": "Si se distribuyen los recursos de la memoria de un programa entre los distintos canales, el algoritmo de dispatching se distorsionara ('el mas corto primero'). Debido a este mal uso de los canales, que hace que los mismo esten frecuentemente ocupados, se producirán colas de espera, y por tanto, un desbalance de la mezcla.",
                "esCorrecta": false
            },
            {
                "respuesta": "Si se distribuyen los archivos de un programa entre los distintos canales, el algoritmo de dispatching se distorsionara ('el mas corto primero'). Debido a este mal uso de los canales, que hace que los mismo procesos frecuentemente ocupados, se producirán muchos gastos de recursos del sistema, y por tanto, un desbalance de la mezcla.",
                "esCorrecta": false
            },
            {
                "respuesta": "Si se distribuyen los archivos de un programa entre los distintos canales, el algoritmo de dispatching se distorsionara ('el mas corto primero'). Debido a este mal uso de los canales, que hace que los mismo esten frecuentemente ocupados, se producirán colas de espera, y por tanto, un desbalance de la mezcla.",
                "esCorrecta": true
            }
        ]
    },
    {
        "id_pregunta": 6,
        "pregunta": "Definir: Tráfico de E/S, Driver de E/S, Planeador de E/S, Controlador de E/S.",
        "respuestas": [
            {
                "respuesta": "1) Tráfico de E/S: rafagas de informacion entre dipositivos, canales y memoria. 2) Drivers de Dispositivos.: Módulo asociado a cada tipo de dispositivo, es el encargado de comunicarse con el canal de E/S ya que sabe como funciona y como proporcionarle u obtener informacion de el. Maneja las interrupciones. 3) Planeador de E/S: Módulo encargado de asignar una solicitud de E/S al controlador de E/S y establecer el camino al dispositivo. 4) Controlador de E/S: Es el encargado de transferir los datos entre el periferico que controla y su buffer local. En DMA transfiere los datos directamente a memoria.",
                "esCorrecta": true
            },
            {
                "respuesta": "1) Tráfico de E/S: rafagas de informacion entre dipositivos. 2) Drivers de Dispositivos.: programa asociado a cada tipo de dispositivo, es el encargado de comunicarse con el canal de E/S y CPU ya que sabe como funciona y como proporcionarle u obtener informacion de el. Maneja las interrupciones. 3) Planeador de E/S: Módulo encargado de asignar una solicitud de E/S al controlador de E/S y establecer el camino al dispositivo. 4) Controlador de E/S: Es el encargado de transferir los datos entre el periferico que controla y su buffer local. En Caché transfiere los datos directamente a memoria.",
                "esCorrecta": false
            },
            {
                "respuesta": "1) Tráfico de E/S: informacion entre dipositivos, buffer y memoria. 2) Drivers de Dispositivos: Módulo asociado a cada tipo de dispositivo, es el encargado de controlar el canal de E/S ya que sabe como funciona y como proporcionarle u obtener informacion de el. Maneja las interrupciones. 3) Planeador de E/S: Módulo encargado de asignar una solicitud de E/S al controlador de E/S. 4) Controlador de E/S: Es el encargado de transferir los datos entre el periferico que controla.",
                "esCorrecta": false
            }
        ]
    },
    {
        "id_pregunta": 7,
        "pregunta": "¿Qué introdujeron estos conceptos: Monitor simple, Operación Off-Line, Buffering, Spooling?",
        "respuestas": [
            {
                "respuesta": "1) Monitor simple: un SO rudimentario. 2)Operación Off-line: independencia de dispositivos 3) Buffering: mecanismos de interrupciones 4) Spooling: pool de trabajos, multiprogramacion",
                "esCorrecta": true
            },
            {
                "respuesta": "1) Monitor simple: independencia de dispositivos. 2) Operación Off-line: mecanismos de interrupción. 3) Buffering: familia IA-32 4) Spooling: multiprogramacion",
                "esCorrecta": false
            },
            {
                "respuesta": "1) Monitor simple: multiprogramación. 2) Operación Off-line: interrupciones avanzadas 3) Buffering: pool de trabajos 4) Spooling: operaciones simultáneas on-line",
                "esCorrecta": false
            }
        ]
    },
    {
        "id_pregunta": 8,
        "pregunta": "Definir y dar ejemplos de Event-Driven (o Queve-Driven) y Proccess-Driven.",
        "respuestas": [
            {
                "respuesta": "1) Event - Driven: los procesos son disparados por eventos externos. Ej: Sistema de inyeccion de combustible, Control de estado de las funciones vitales de un paciente. 2) Proccess - Driven: los procesos son iniciados por sus características intrínsecas según la utilizacion que se le quiera dar al equipo. Ej: Procesos con prioridad, Procesos limitados por CPU para una mezcla limitada por E/S.",
                "esCorrecto": true
            },
            {
                "respuesta": "1) Event - Driven: eventos externos disparados por los procesos. Ej: Sistema de inyeccion en procesos, Control de estado de las funciones vitales de un paciente. 2) Proccess - Driven: hilos iniciados por sus características intrínsecas según la utilizacion que se le quiera dar al equipo. Ej: Procesos con prioridad, Procesos limitados por CPU para una mezcla limitada por E/S.",
                "esCorrecto": false
            },
            {
                "respuesta": "1) Event - Driven: procesos disparadores de eventos externos. 2) Proccess - Driven: los procesos son iniciados por sus características intrínsecas según la utilizacion que se le quiera dar al equipo. Ej: Procesos con prioridad, Procesos ilimitados por CPU para una mezcla limitada por E/S.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 9,
        "pregunta": "¿Cómo justificaría la incorporación de un nuevo módulo administrador de recursos?",
        "respuestas": [
            {
                "respuesta": "Cuando los trabajos no usan los recursos de manera eficiente teniendo en cuenta los objetivos, presentando mezclas no deseadas en la CPA. ",
                "esCorrecto": true
            },
            {
                "respuesta": "Cuando los trabajos no usan los recursos de manera eficiente teniendo en cuenta los objetivos, presentando mezclas no deseadas en el bloque de control de proceso (PCB). ",
                "esCorrecto": false
            },
            {
                "respuesta": "Cuando los trabajos no usan los recursos de manera eficiente teniendo en cuenta los objetivos, presentando mezclas no deseadas en un sistema de archivos NTFS. ",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 10,
        "pregunta": "Los sistemas de multiprogramación avanzada poseen mecanismos elaborados de conmutación de la CPU. Dé un ejemplo de ello.",
        "respuestas": [
            {
                "respuesta": "Utilizar colas cíclicas realimentadas, en donde se utiliza como política “el más corto primero”, es decir, se da prioridad a la aplicación que en el menor tiempo solicite una operación de E/S.",
                "esCorrecto": false
            },
            {
                "respuesta": "Utilizar planificación circular, en donde se utiliza como política “el qué primero llega”, es decir, se da prioridad a la primera aplicación qué realizó una petición",
                "esCorrecto": true
            },
            {
                "respuesta": "No existe aún hoy en día un mecanismo qué de manera eficiente conmute la CPU entre las diversas aplicaciones.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 11,
        "pregunta": "¿Cuáles son los recursos críticos de los siguientes SOs: Multiprogramacion Básica, Multiprogramacion Avanzada, Tiempo Compartido, Tiempo Real?",
        "respuestas": [
            {
                "respuesta": "1) Multiprogramación básica: Memoria 2) Multiprogramación avanzada: Canales 3) Tiempo compartido: CPU 4) Tiempo real: Según los procesos que se corren E/S o CPU",
                "esCorrecto": false
            },
            {
                "respuesta": "1) Multiprogramación básica: Memoria plana 2) Multiprogramación avanzada: Canales de comunicación 3) Tiempo compartido: CPU y Memoria 4) Tiempo real: Según los procesos que se corren E/S o CPU",
                "esCorrecto": true
            },
            {
                "respuesta": "1) Multiprogramación básica: Memoria segmentada 2) Multiprogramación avanzada: Canales  3) Tiempo compartido: CPU 4) Tiempo real: Según los procesos que se corren E/S o CPU",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 12,
        "pregunta": "¿Qué implicancia tendría que la elección de la tabla de páginas sobre la cuál se elegirá la página víctima se efectúe probabilísticamente?",
        "respuestas": [
            {
                "respuesta": "Si la página víctima se eligiera en forma probabilística habría más interrupciones por falla de página y por lo tanto alto ratio de paginación",
                "esCorrecto": false
            },
            {
                "respuesta": "Si la página víctima se eligiera en forma probabilística habría menos interrupciones por falla de página y por lo tanto bajo ratio de paginación",
                "esCorrecto": true
            },
            {
                "respuesta": "Si la página víctima se eligiera en forma probabilística habría más interrupciones por falla de página y por lo tanto bajo ratio de paginación",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 13,
        "pregunta": "(SUBCOLA 1) N1 = 5 Q1 = 5 | (SUBCOLA 2) N2 = 10 Q2 = 10 | (SUBCOLA 3) N3 = [uInfinito] Q3 = 30, cuya regla de visita establece que: “Siempre que en la subcola derecha haya un proceso listo para correr será atendido”. ¿Qué conclusiones puede sacar?",
        "respuestas": [
            {
                "respuesta": "Penaliza a los procesos cortos y favorece a los largos, los procesos cortos se ven penalizados ya que cada vez que se comience a ejecutar un proceso largo este sera atendido hasta su finalizacion y los cortos que lo siguen deberan esperar. Seria los mismo que un algoritmo FCFS con una sola cola.",
                "esCorrecto": true
            },
            {
                "respuesta": "Penaliza a los procesos largos y favorece a los cortos, los procesos largos se ven penalizados ya que cada vez que se comience a ejecutar un proceso corto este sera atendido hasta su finalizacion y los largos que lo siguen deberan esperar. Seria los mismo que un algoritmo FCFS con una sola cola.",
                "esCorrecto": false
            },
            {
                "respuesta": "No penaliza a un proceso, ya qué el TAT es constante sin importar el tamaño del proceso en cuestión",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 14,
        "pregunta": "¿Por qué la segmentación facilita la compartición de código?",
        "respuestas": [
            {
                "respuesta": "Porque se puede asociar un mismo segmento a distintos procesos mediante la tabla de segmentos de cada proceso. Ademas cada segmento esta definido apoyado sobre la perspectiva del usuario semanticamente (codigo, funciones, variables) lo que facilita la comparticion. Por ejemplo se podria compartir entre varios procesos un segmento en el cual se encuentran funciones comunes a estos.",
                "esCorrecto": true
            },
            {
                "respuesta": "Porque se puede asociar un mismo segmento a distintos procesos mediante la tabla de paginación de cada proceso. Ademas cada segmento esta definido apoyado sobre la perspectiva del usuario semanticamente (codigo, funciones, variables) lo que facilita la comparticion de hilos. Por ejemplo se podria compartir entre varios procesos un segmento en el cual se encuentran funciones comunes a estos.",
                "esCorrecto": false
            },
            {
                "respuesta": "Porque se puede asociar un mismo paginado de distintos procesos mediante la tabla de segmentos de cada proceso. Ademas cada página esta definido apoyado sobre la perspectiva del usuario semanticamente (codigo, funciones, variables) lo que facilita la comparticion. Por ejemplo se podria compartir entre varios procesos un segmento en el cual se encuentran funciones comunes a estos.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 15,
        "pregunta": "En un SO de 3 niveles, ¿qué cola tiene mayor capacidad, la del ONI o la del OBN? Justificar.",
        "respuestas": [
            {
                "respuesta": "La cola que posee mayor capacidad es la del OBN, es conveniente que esta cola tenga mayor capacidad ya que almacena los procesos iniciados (recien llegados y parcialmente ejecutados) con los cuales el OBN efectuara las futuras mezclas (tomando el las decisiones evitando sobrecargar al ONI) de la CPA para mejorar el rendimiento del sistema con vista a los objetivos. Ademas como los procesos de esta cola reciden en memoria virtual el limite de capacidad que se le impone lo define el sistema lo cual no sucede con la cola del ONI.",
                "esCorrecto": false
            },
            {
                "respuesta": "Niguna de las 2 anteriores. La cola con mayor capacidad es la OAN (planificador a largo plazo)",
                "esCorrecto": false
            },
            {
                "respuesta": "La cola que posee mayor capacidad es la del ONI, es conveniente que esta cola tenga mayor capacidad ya que almacena los procesos iniciados (recien llegados y parcialmente ejecutados) con los cuales el ONI efectuara las futuras mezclas (tomando el las decisiones evitando sobrecargar al OBN) de la CPA para mejorar el rendimiento del sistema con vista a los objetivos. Ademas como los procesos de esta cola reciden en memoria virtual el limite de capacidad que se le impone lo define el sistema lo cual no sucede con la cola del OBN.",
                "esCorrecto": true
            }
        ]
    },
    {
        "id_pregunta": 16,
        "pregunta": "¿Por qué motivo en un sistema con memoria virtual es importante ante la solicitud de una nueva página por parte de un proceso, conocer si la vecindad cambia o crece? ¿Cómo actúa en cada caso?",
        "respuestas": [
            {
                "respuesta": "Es importante porque en caso de que la vecindad crece en la proxima intervencion del ONI este le agrandara la vecindad para que pueda correr sin ocasionar falla de pagina. El sistema para discernir entre un cambio o crecimiento evalua el ratio de repaginacion. Si el mismo es elevado la vecindad crece y si es bajo cambia. Ante un crecimiento: le asigna mas marcos al proceso, si no hay marcos disponibles puede hacer tres cosas: sacarle paginas a otro proceso de menos prioridad o mal comportamiento, suspender un proceso de menos prioridad, suspender el proceso hasta que halla marcos disponibles para el CPT del mismo. Ante un cambio: aplicar el algoritmo de reemplazo de pagina en forma local",
                "esCorrecto": true
            },
            {
                "respuesta": "Es importante porque en caso de que la vecindad crece en la proxima intervencion de la CPU, este le agrandara la vecindad para que pueda correr sin ocasionar falla de segmento. El sistema para discernir entre un cambio o crecimiento evalua el ratio de repaginacion. Si el mismo es elevado la vecindad crece y si es bajo cambia. Ante un crecimiento: le asigna mas marcos al proceso, si no hay marcos disponibles puede hacer tres cosas: sacarle paginas a otro proceso de menos prioridad o mal comportamiento, suspender un proceso de menos prioridad, suspender el proceso hasta que halla marcos disponibles para el CPT del mismo. Ante un cambio: aplicar el algoritmo de reemplazo de pagina en forma local",
                "esCorrecto": false
            },
            {
                "respuesta": "Ninguna es correcta",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 17,
        "pregunta": "¿Cuáles son las ventajas de construir una red de procesamiento?",
        "respuestas": [
            {
                "respuesta": "Independizar las aplicaciones de la ubicación física de los datos y/o programas. Facilidad para comunicarse entre sistemas",
                "esCorrecto": true
            },
            {
                "respuesta": "Independizar las aplicaciones de la ubicación lógica de los procesos. Facilidad para comunicarse entre sistemas",
                "esCorrecto": false
            },
            {
                "respuesta": "Independizar las aplicaciones de la ubicación física de los registros físicos/lógicos. Facilidad para comunicarse entre sistemas",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 18,
        "pregunta": "¿Cuál es la diferencia entre red de procesamiento y procesamiento distribuido?",
        "respuestas": [
            {
                "respuesta": "Red de Procesamiento: Considera que una aplicación ha sido desarrollada para trabajar en varios procesadores, de tal forma que en cada nodo se desarrollan determinadas funciones que en totalidad forman el sistema completo | Procesamiento Distribuido: Considera que una aplicación ha sido desarrollada para trabajar en varios procesadores, de tal forma que en cada nodo se desarrollan determinadas funciones que en totalidad forman el sistema completo. Ante un crecimiento: le asigna mas marcos al proceso, si no hay marcos disponibles puede hacer tres cosas: sacarle paginas a otro proceso de menos prioridad o mal comportamiento, suspender un proceso de menos prioridad, suspender el proceso hasta que halla marcos disponibles para el CPT del mismo.",
                "esCorrecto": false
            },
            {
                "respuesta": "Red de Procesamiento: cada nodo se lo considera como un sistema multipropósito capaz de: -ofrecer funciones y/o servicios a los usuarios -trabajar en forma independiente | Procesamiento Distribuido: Considera que una aplicación ha sido desarrollada para trabajar en varios procesadores, de tal forma que en cada nodo se desarrollan determinadas funciones que en totalidad forman el sistema completo",
                "esCorrecto": true
            },
            {
                "respuesta": "Red de Procesamiento: cada nodo se lo considera como un sistema distribuido capaz de: -ofrecer rutinas del SO específicas -trabajar en relación de dependencia | Procesamiento Distribuido: Considera que una aplicación ha sido desarrollada para trabajar en sólo un procesador, de tal forma que en cada nodo se desarrollan determinadas funciones que en totalidad forman el sistema completo ",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 19,
        "pregunta": "Dado un procesador determinado; ¿cómo se logra mayor capacidad de cálculo, agregando 3 procesadores iguales al existente o cambiando por uno 4 veces más potente? ¿Por qué?",
        "respuestas": [
            {
                "respuesta": "Cambiando por uno 4 veces más potente, porque al aumentar la cantidad de procesadores en 3 no se va a cuadriplicar la capacidad de procesamiento debido a que hay cierta cantidad de tiempo de procesamiento requerido para mantener al conjunto funcionando correctamente",
                "esCorrecto": true
            },
            {
                "respuesta": "Cambiando por uno 3 veces más potente, porque al aumentar la cantidad de procesadores en 4 no se va a cuadriplicar la capacidad de procesamiento debido a que hay cierta cantidad de tiempo de buffering requerido para mantener al conjunto funcionando correctamente",
                "esCorrecto": false
            },
            {
                "respuesta": "Ninguna de las anteriores",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 20,
        "pregunta": "Explique los pasos que sigue un sistema de 3 niveles para correr en una mezcla Batch un programa con tiempo límite de finalización.",
        "respuestas": [
            {
                "respuesta": "1) El ONI calcula el total de recursos que va a utilizar el programa en unidades de servicio (mide el avance del programa en la mezcla) 2) Al final de cada período el ONI controla el grado de avance del programa y, según éste retrasado o adelantado se le modificara si es necesario la prioridad relativa",
                "esCorrecto": true
            },
            {
                "respuesta": "1) El OBN calcula el total de recursos que va a utilizar el programa en unidades de servicio (mide el avance del programa en la mezcla) 2) Al final de cada período el OBN controla el grado de avance del programa y, según éste retrasado o adelantado se le modificara si es necesario la prioridad relativa",
                "esCorrecto": false
            },
            {
                "respuesta": "1) El OAN calcula el total de recursos que va a utilizar el programa en unidades de servicio (mide el avance del programa en la mezcla) 2) Al final de cada período el OAN controla el grado de avance del programa y, según éste retrasado o adelantado se le modificara si es necesario la prioridad relativa",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 21,
        "pregunta": "Imagine un proceso corriendo en un sistema de paginación; las páginas del mismo se identifican con una con una letra. Suponga que la secuencia con que referencia sus páginas en un intervalo del ONI es la siguiente: t = 0, A-B-C-E-F-D-E-F-K-L-M-D-E-F-N-O-P-D-E-F-Q-R-S-D-E-F-T-U-V, t = 1 El sistema dispone de una lista de 8 registros asociativos de hard para la asociación entre direcciones lógicas y ubicaciones físicas además, claro está, de la tabla de páginas. Esta lista se mantiene con un mecanismo LFU (bit de referencia). ¿Cuántas referencias del proceso en cuestión han podido ser validadas sin recurrir a otro mecanismo que no sea la lista?",
        "respuestas": [
            {
                "respuesta": "DFDFFEEFDED",
                "esCorrecto": false
            },
            {
                "respuesta": "DFDEFFDFDEE",
                "esCorrecto": false
            },
            {
                "respuesta": "EFDEFDEFDEF",
                "esCorrecto": true
            }
        ]
    },
    {
        "id_pregunta": 22,
        "pregunta": "¿Qué conclusiones pueden sacarse respecto de las caracteristicas de un programa conociendo su ratio de paginación? ¿Por qué?",
        "respuestas": [
            {
                "respuesta": "Con su ratio de paginación no podemos sacar ninguna conclusión, porque el proceso puede producir una brusca variación de la vecindad, ya sea porque su localidad crece o cambia. En cambio, conociendo su ratio de repaginación, un proceso que crece tiene elevado ratio de repaginación y un proceso que cambia tendrá un pequeño ratio de repaginación.",
                "esCorrecto": true
            },
            {
                "respuesta": "Con su memoria de paginación no podemos sacar ninguna conclusión, porque el proceso puede producir una brusca variación de la vecindad, ya sea porque su localidad crece o cambia. En cambio, conociendo su ratio de repaginación, un proceso que crece tiene elevado ratio de repaginación y un proceso que cambia tendrá un pequeño ratio de repaginación.",
                "esCorrecto": false
            },
            {
                "respuesta": "Con su segmento de memoria no podemos sacar ninguna conclusión, porque el proceso puede producir una brusca vulnerabilidad de la vecindad, ya sea porque su localidad crece o cambia. En cambio, conociendo su memoria de repaginación, un proceso que crece tiene elevado ratio de repaginación y un proceso que cambia tendrá un pequeño ratio de repaginación.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 23,
        "pregunta": "Imagine un proceso corriendo en un sistema de paginación; las páginas del mismo se identifican con una con una letra. Suponga que la secuencia con que referencia sus páginas en un intervalo del ONI es la siguiente: t = 0, A-B-C-E-F-D-E-F-K-L-M-D-E-F-N-O-P-D-E-F-Q-R-S-D-E-F-T-U-V, t = 1 El sistema dispone de una lista de 8 registros asociativos de hard para la asociación entre direcciones lógicas y ubicaciones físicas además, claro está, de la tabla de páginas. Esta lista se mantiene con un mecanismo LFU (bit de referencia). ¿Qué inconvenientes presenta?",
        "respuestas": [
            {
                "respuesta": "Que puedo dar de baja una página que a continuación se vuelve a referenciar",
                "esCorrecto": true
            },
            {
                "respuesta": "Que puedo dar de baja un marco que a continuación se vuelve a referenciar",
                "esCorrecto": false
            },
            {
                "respuesta": "Que puedo dar de baja un proceso que a continuación se vuelve a referenciar",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 24,
        "pregunta": "Explique y justifique cuáles son los objetivos comunes con los que se desarrollaron todos los algoritmos de reemplazo de páginas.",
        "respuestas": [
            {
                "respuesta": "Que produzca el menor numero de fallas de páginas, porque se consumirá menos tiempo en procesar un programa ya que no se necesitan tantas secuencias de paginación. Esto incluye: -Evitar que se presente la anomalia de Belady. -Evitar el trashing. -Aproximarse al CPT",
                "esCorrecto": true
            },
            {
                "respuesta": "Que produzca el mayor numero de fallas de páginas, porque se consumirá más tiempo en procesar un programa ya que no se necesitan tantas secuencias de segmentación. Esto incluye: -Evitar que se presente la anomalia de Belady. -Evitar el spooling. -Aproximarse al CTP",
                "esCorrecto": false
            },
            {
                "respuesta": "Que produzca el mayor numero de fallas de segmentos, porque se consumirá más tiempo en procesar un programa ya que no se necesitan tantas secuencias. Esto incluye: -Evitar que se presente la anomalia de Belady. -Evitar el spooling. -Aproximarse al CTP",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 25,
        "pregunta": "Explicar por que es frecuentemente necesario recurrir a un Cross-Compiler o a un Meta-Asembler para el desarrollo de estos sistemas.",
        "respuestas": [
            {
                "respuesta": "El sistema es desarrollado en un hardware con un SO que soporta desarrollo de programas diferente al hardware en el que va a ejecutarse la aplicación de tiempo real (los sistemas estan desarrollados a medida solo pensado en el uso que le va a dar la aplicación) y el Cross-compiler o el Meta-assembler permiten que estando en una máquina se pueda crear código para una arquitectura distinta a la esta.",
                "esCorrecto": true
            },
            {
                "respuesta": "El sistema es desarrollado en un hardware con un SO que soporta desarrollo de programas similares al hardware en el que va a ejecutarse la aplicación de tiempo real (los sistemas estan desarrollados a medida solo pensado en el uso de procesadores x86 que le va a dar la aplicación) y el Cross-compiler o el Meta-assembler permiten que estando en una máquina se pueda crear código para una arquitectura distinta a la esta.",
                "esCorrecto": false
            },
            {
                "respuesta": "El sistema es desarrollado en un hardware muy específico con un SO que soporta desarrollo de programas diferente al hardware y multihilos en el que va a ejecutarse la aplicación de tiempo real (los sistemas estan desarrollados a medida solo pensado en el uso que le va a dar la aplicación) y el Cross-compiler o el Meta-assembler permiten que estando en una máquina se pueda crear código para una arquitectura distinta a la esta.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 26,
        "pregunta": "¿Cuáles son los objetivos de explotación y describir las características de una mezcla ideal de procesos para: Sistemas Batch - Sistemas de Tiempo Compartido?",
        "respuestas": [
            {
                "respuesta": "Sistemas Batch: Máximar la utilización del hard, trata de correr la mayor cantidad de trabajos por unidad de tiempo. Mezcla ideal: Heterogénea con respecto a los recursos, ya que si la aplicación de la mezcla utiliza distintos recursos se puede balancear el uso de los mismos. Tiempo Compartido: Pronta respuesta al usuario. Puede sacrificar el uso del hard, ya que se basa en brindar una respuesta rápida a los usuarios. Mezcla ideal: Homogénea en cuanto a las funciones utilizadas, si todas los procesos utilizan una misma función, se reduce el esfuerzo del sistema de traerla y dejarla disponible para su uso.",
                "esCorrecto": true
            },
            {
                "respuesta": "Sistemas Batch: Pronta respuesta al usuario. Puede sacrificar el uso del hard, ya que se basa en brindar una respuesta rápida a los usuarios. Mezcla ideal: Heterogénea con respecto a los recursos, ya que si la aplicación de la mezcla utiliza distintos recursos se puede balancear el uso de los mismos. Tiempo Compartido: Máximar la utilización del hard, trata de correr la mayor cantidad de trabajos por unidad de tiempo. Mezcla ideal: Heterogénea con respecto a los recursos, ya que si la aplicación de la mezcla utiliza distintos recursos se puede balancear el uso de los mismos.",
                "esCorrecto": false
            },
            {
                "respuesta": "Sistemas Batch: Pronta respuesta al usuario. Puede sacrificar el uso del hard, ya que se basa en brindar una respuesta rápida a los usuarios. Mezcla ideal: Homogénea en cuanto a las funciones utilizadas, si todas los procesos utilizan una misma función, se reduce el esfuerzo del sistema de traerla y dejarla disponible para su uso. Tiempo Compartido: Máximar la utilización del hard, trata de correr la mayor cantidad de trabajos por unidad de tiempo. Mezcla ideal: Homogénea en cuanto a las funciones utilizadas, si todas los procesos utilizan una misma función, se reduce el esfuerzo del sistema de traerla y dejarla disponible para su uso.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 27,
        "pregunta": "En un medio de recursos compartidos, ¿puede el compilador generar todas las funciones en un proceso compilado? Explique.",
        "respuestas": [
            {
                "respuesta": "No, no se permite porque la idea de ámbito de procesamiento contiene una idea interfases extendidas y una idea de coordinación  y control. Como muchos procesos necesitan funciones idénticas, se definen mecanismos que permitan compartir código y usar eficientemente la memoria. Cuando el  compilador necesita una de las interfases extendidas solo llama al modulo.",
                "esCorrecto": true
            },
            {
                "respuesta": "No, no se permite porque el procesamiento contiene una idea de coordinación  y control. Como muchos espacios de memoria contigua necesitan funciones idénticas, se definen mecanismos que permitan compartir código y usar eficientemente la memoria. Cuando el  compilador necesita una de las interfases extendidas solo llama al modulo.",
                "esCorrecto": false
            },
            {
                "respuesta": "No, no se permite porque la memoria contiene una idea de interfaces extendidas y una idea de coordinación  y control. Como muchos procesos necesitan funciones segmentadas, se definen mecanismos que permitan compartir código y usar eficientemente la memoria. Cuando el  compilador necesita una de las interfaces extendidas solo llama al modulo público.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 28,
        "pregunta": "¿Cómo se aprovecha una estructura de subcolas en un sistema de Tiempo Compartido?",
        "respuestas": [
            {
                "respuesta": "Una estructura de subcolas permite, en este tipo de sistemas, distinguir los programas largos de los cortos para privilegiar o beneficiar a estos ultimos repectos de los demas, y como consecuencia disminuir para los programas largos el TAT y el TIEMPO DE RESPUESTA. La regla de residencia esta dada por los golpes de la memoria auxiliar que recibe un proceso \"N\" y la de visita es la que penaliza a los programas largos.",
                "esCorrecto": false
            },
            {
                "respuesta": "Una estructura de subcolas permite, en este tipo de sistemas, distinguir lás páginas largas de los cortas para privilegiar o beneficiar a estas ultimas repectos de los demas, y como consecuencia disminuir para las páginas largas el numero efectivo de cargas y descargas en memoria. La regla de residencia esta dada por los golpes de CPU que recibe un proceso \"N\" y la de visita es la que penaliza a las páginas largas.",
                "esCorrecto": false
            },
            {
                "respuesta": "Una estructura de subcolas permite, en este tipo de sistemas, distinguir los programas largos de los cortos para privilegiar o beneficiar a estos ultimos repectos de los demas, y como consecuencia disminuir para los programas largos el numero efectivo de cargas y descargas en memoria. La regla de residencia esta dada por los golpes de CPU que recibe un proceso \"N\" y la de visita es la que penaliza a los programas largos.",
                "esCorrecto": true
            }
        ]
    },
    {
        "id_pregunta": 29,
        "pregunta": "¿Cuáles son los fundamentos económicos de la administracion de recursos en un sistema de computación?",
        "respuestas": [
            {
                "respuesta": "Costo: reside en el incremento de los beneficios economicos que obtiene una empresa debido a la incorporacion de un sistema de computacion. El valor puede derivar de la reduccion de los costos de creacion, manipulacion, clasificacion y almacenamiento de datos; del aumento de la productividad de los usuarios y profesionales ligados al sistema; de la provision de informacion de mejor calidad y en margen de tiempo mas conveniente proporcionando mayores posibilidades de correlacionar informacion; y proveyendo metodologias de planificacion de negocios mas sofisticadas. Debe ser medido por el valor de la informacion que el produce, un retardo en ella produce costo. Valor: incluye el costo del software, el costo del staff de profeionales derivados del desarrollo de aplicaciones y del mantenimiento de la informacion y de los programas, y de los costos derivados del efectivo uso del equipo.",
                "esCorrecto": false
            },
            {
                "respuesta": "Costo: incluye el costo del hardware, el costo del staff de profeionales derivados del desarrollo de aplicaciones y del mantenimiento de la informacion y de los programas, y de los costos derivados del efectivo uso del equipo. Valor: reside en el incremento de los beneficios economicos que obtiene una empresa debido a la incorporacion de un sistema de computacion. El valor puede derivar de la reduccion de los costos de creacion, manipulacion, clasificacion y almacenamiento de datos; del aumento de la productividad de los usuarios y profesionales ligados al sistema; de la provision de informacion de mejor calidad y en margen de tiempo mas conveniente proporcionando mayores posibilidades de correlacionar informacion; y proveyendo metodologias de planificacion de negocios mas sofisticadas. Debe ser medido por el valor de la informacion que el produce, un retardo en ella produce costo.",
                "esCorrecto": true
            },
            {
                "respuesta": "Costo: incluye el costo del software, el costo del staff de profeionales derivados del desarrollo de aplicaciones y del mantenimiento de la informacion y de los programas, y de los costos derivados del efectivo uso del equipo. Valor: reside en el incremento de los beneficios economicos que obtiene una empresa debido a la incorporacion de un sistema de computacion. El valor puede derivar de la reduccion de los costos de creacion, manipulacion, clasificacion y almacenamiento de datos; del aumento de la productividad de los usuarios y profesionales ligados al sistema; de la provision de informacion de mejor calidad y en margen de tiempo mas conveniente proporcionando mayores posibilidades de correlacionar informacion; y proveyendo metodologias de planificacion de negocios mas sofisticadas. Debe ser medido por el valor de la informacion que el produce, un retardo en ella produce costo.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 30,
        "pregunta": "Explicar qué se entiende por máquinas virtuales.",
        "respuestas": [
            {
                "respuesta": "Cuando en un mismo hardware pueden correr varios SO (llamados de produccion) y cada uno trabaja a nivel lógico como si fuera el único SO que está trabajando sobre ese hardware . Un SO corriendo en la maquina fisica  puede crear la ilusion de procesos multiples que se ejecutan  cada uno en su propio procesador con su propia memoria (virtual). Este SO planifica los recursos de la maquina fisica para compartirlos entre los distintos SO de produccion proporcionandoles una copia virtual del hardware fisico.",
                "esCorrecto": true
            },
            {
                "respuesta": "Cuando en un mismo hardware pueden correr varios SO y cada uno trabaja a nivel lógico como si fuera el único SO que está trabajando sobre ese hardware. Un SO corriendo en la maquina fisica  puede crear la ilusion de hilos multiples que se ejecutan  cada uno en su propio núcleo con su propia memoria paginada. Este SO planifica los recursos de la maquina fisica para compartirlos entre los distintos SO de produccion proporcionandoles una copia virtual del hardware fisico.",
                "esCorrecto": false
            },
            {
                "respuesta": "Ninguna de las anteriores",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 31,
        "pregunta": "En un sistema de paginación. Existen procesos cuyo grado de avance depende del número de páginas que el sistema le permite cargar en el almacenamiento primario. Existen, por el contrario, otros cuyo grado de avance es relativamente insensible a este número.Los sistemas más desarrollados son capaces de diferenciar uno y otro tipo de procesos. ¿Qué parámetros evalúan estos sistemas para lograr establecer esta diferencia?",
        "respuestas": [
            {
                "respuesta": "Evalúan la vecindad del programa, si esta crece es porque el programa depende del numero de paginas que el sistema le permite cargar (CPT) y si esta cambia el programa es insensible a dicho numero.",
                "esCorrecto": true
            },
            {
                "respuesta": "Evalúan la cantidad de memoria auxiliar y procesos qué pueden almacenarse en memoria principal, si esta crece es porque el programa depende del numero de paginas que el sistema le permite cargar (CPT) y si esta cambia el programa es insensible a dicho numero.",
                "esCorrecto": false
            },
            {
                "respuesta": "Evalúan la intensidad de comunicación entre procesos por medio de un buzón, si esta crece es porque el programa depende del numero de paginas que el sistema le permite cargar (CPT) y si esta cambia el programa es insensible a dicho numero.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 32,
        "pregunta": "En una instalación por razones de evolución se verifica que la capacidad de CPU es insuficiente. Frente a esta situación: ¿Cuáles son las 2 posibles soluciones?",
        "respuestas": [
            {
                "respuesta": "-Gama compatible de máquina, adaptable mediante cambio estándar de la unidad central. -Solución multiprocesador, adjudicación de 1 o más unidades centrales.",
                "esCorrecto": true
            },
            {
                "respuesta": "-Gama compatible con memoria virtual de la máquina, adaptable mediante cambio estándar de la unidad central. -Solución multiprocesador, adjudicación de 1 o más unidades centrales.",
                "esCorrecto": false
            },
            {
                "respuesta": "-Gama adaptable mediante cambio estándar de la unidad central. -Solución multiprocesador, adjudicación de 1 o más unidades centrales.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 33,
        "pregunta": "¿Qué se entiende por Estado de Trabajo y Estado de Control?",
        "respuestas": [
            {
                "respuesta": "Estado de Trabajo: Estado donde corren los procesos de usuarios. Cada vez que ocurre una trampa o interrupcion el SO pasa a estado de control. Solo pueden ejecutarse intrucciones no privilegiadas. Al ejecutarse una instrucción privilegiada se produce una interrupcion. Estado de Control: Se realizan instrucciones de trabajo y privilegiadas. El SO toma el control cada vez que se produce una trampa o interrupcion lo cual le permite al SO administrar al sistema informatico proporcionandole integridad y control apropiado sobre los recursos.",
                "esCorrecto": true
            },
            {
                "respuesta": "Estado de Trabajo: Se realizan instrucciones de trabajo y privilegiadas. El SO toma el control cada vez que se produce una trampa o interrupcion lo cual le permite al SO administrar al sistema informatico proporcionandole integridad y control apropiado sobre los recursos. Estado de Control: Estado donde corren los procesos de usuarios. Cada vez que ocurre una trampa o interrupcion el SO pasa a estado de control. Solo pueden ejecutarse intrucciones no privilegiadas. Al ejecutarse una instrucción privilegiada se produce una interrupcion.",
                "esCorrecto": false
            },
            {
                "respuesta": "Estado de Trabajo: Estado donde corren los procesos privilegiados del SO. Cada vez que ocurre una trampa o interrupcion el SO pasa a estado de control. Solo pueden ejecutarse intrucciones en modo usuario. Al ejecutarse una instrucción de usuario se produce una interrupcion. Estado de Control: Se realizan instrucciones de trabajo y modo usuario. El usuario toma el control cada vez que se produce una trampa o interrupcion lo cual le permite al SO administrar al sistema informatico proporcionandole integridad y control apropiado sobre los recursos.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 34,
        "pregunta": "En una instalación por razones de evolución se verifica que la capacidad de CPU es insuficiente. Frente a esta situación: ¿Qué consideraciones deben efectuarse para optar por una u otra solución?",
        "respuestas": [
            {
                "respuesta": "-Las gamas compatibles admiten un factor por encima del doble cuando se pasa de un modelo a uno superior. -La solución multiprocesador pasa de una máquina monoprocesador a una máquina de 2 procesadores, luego a 4, etc. Cuando el numero de procesadores es elevado conviene sustituir una unidad central por otra n veces más potente.",
                "esCorrecto": true
            },
            {
                "respuesta": "-Las gamas compatibles admiten un factor por encima del doble cuando se pasa de un modelo plano a uno de planificación. -La solución multiprocesador pasa de una máquina monoprocesador a una máquina de 2 procesadores, luego a 4, etc. Cuando el numero de procesadores es elevado conviene sustituir una unidad central por otra n veces más potente.",
                "esCorrecto": false
            },
            {
                "respuesta": "-Las gamas superiores compatibles admiten un factor por encima del doble cuando se pasa de un modelo páginado a uno superior. -La solución multiprocesador pasa de una máquina monoprocesador a una máquina virtual de 2 procesadores, luego a 4, etc. Cuando el numero de procesadores es elevado conviene sustituir una unidad central por otra n veces más potente.",
                "esCorrecto": false
            }
        ]
    },
    {
        "id_pregunta": 35,
        "pregunta": "La aparición de un “tiempo de carga” introdujo una serie de innovaciones en los sistemas de computación que constituyen la base del desarrollo posterior de los SO hacia las versiones actuales. ¿Cuáles son esas innovaciones comparando con los sistemas de un tiempo ?",
        "respuestas": [
            {
                "respuesta": "Los procesos son reasignables (compilacion relativa) ya que ahora es el Loader el que carga el programa en memoria teniendo la posibilidad de cargarlo en cualquier conjunto de ubicaciónes contiguas de memoria de direcciones apropiadas mientras que en los sistemas de un tiempo los procesos no eran reasignables (compilacion absoluta). Se realiza asignacion simbolica de dispositivos. En sistemas de un tiempo había inflexibilidad debido a la asignación temprana memoria. La compilación relativa también incluye la posibilidad de combinar programas ya compilados lo que no podia hacerse en sistemas de un tiempo (lo que no permitia enlazar rutinas de los dispositivos de E/S por lo que el compilador debia trabajar mas).",
                "esCorrecto": false
            },
            {
                "respuesta": "Los procesos son reasignables (compilacion relativa) ya que ahora es el Bloque de Control de Procesos el que carga el programa en memoria teniendo la posibilidad de cargarlo en cualquier conjunto de ubicaciónes separadas de memoria de direcciones apropiadas mientras que en los sistemas de un tiempo los procesos no eran reasignables (compilacion absoluta). Se realiza asignacion simbolica de dispositivos. En sistemas de un tiempo había inflexibilidad debido a la asignación temprana memoria. La compilación relativa también incluye la posibilidad de combinar programas ya compilados lo que no podia hacerse en sistemas de un tiempo (lo que no permitia enlazar rutinas de los dispositivos de E/S por lo que el compilador debia trabajar mas).",
                "esCorrecto": false
            },
            {
                "respuesta": "Los procesos son reasignables (compilacion relativa) ya que ahora es OAN el que carga el programa en memoria teniendo la posibilidad de cargarlo en cualquier conjunto de ubicaciónes contiguas de memoria de direcciones apropiadas mientras que en los sistemas de un tiempo los procesos no eran reasignables (compilacion absoluta). Se realiza asignacion simbolica de dispositivos. En sistemas de un tiempo había inflexibilidad debido a la asignación temprana memoria. La compilación relativa también incluye la posibilidad de combinar programas ya compilados lo que no podia hacerse en sistemas de un tiempo (lo que no permitia enlazar rutinas de los dispositivos de E/S por lo que el compilador debia trabajar mas).",
                "esCorrecto": true
            }
        ]
    }
]